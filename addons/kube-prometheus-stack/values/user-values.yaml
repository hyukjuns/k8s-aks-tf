# ETCD / Controller Manager / Scheduler / kubeProxy
kubeControllerManager:
  enabled: false
kubeEtcd:
  enabled: false
kubeScheduler:
  enabled: false
kubeProxy:
  enabled: false
  
# Alertmanager
alertmanager:
  ingress:
    enabled: true
    ingressClassName: external-ingress-nginx-class
    hosts:
      - alertmanager.namutest.site
    path: /
    # tls:
    #   - secretName: namutest.site-20240809
    #     hosts:
    #     - alertmanager.namutest.site
  # service:
  #   port: 9093
  #   targetPort: 9093
  #   type: LoadBalancer
  alertmanagerSpec:
    alertmanagerConfiguration:
      name: global-alertmanager-config
    alertmanagerConfigMatcherStrategy:
      type: None # alertmanagerconfig의 namespace가 alertmanager 설정 중 route.routes.matchers에 label로 등록되는것을 방지 (기본값: OnNamespace)
    
    # NamespaceSelector 가 없을 경우 alertmanager와 같은 namespace에 있는 alertmanagerconfig 만 식별, selector가 있을 경우 selector 적용됨
    alertmanagerConfigNamespaceSelector:
      matchExpressions:
        - key: kubernetes.io/metadata.name
          operator: In
          values:
            - dev
            - default
            - monitoring
    # alertmanagerConfigSelector:
    #     matchExpressions:
    #       - key: team
    #         operator: In
    #         values:
    #           - dev
    #           - infra
    replicas: 1
    resources:
      limits:
        cpu: 200m
        memory: 200Mi
      requests:
        cpu: 100m
        memory: 100Mi

# Grafana
grafana:
  defaultDashboardsTimezone: kst
  adminPassword: admin
  ingress:
    enabled: true
    ingressClassName: external-ingress-nginx-class
    hosts:
      - grafana.namutest.site
    path: /
    # tls:
    #   - secretName: namutest.site-20240809
    #     hosts:
    #     - grafana.namutest.site
  # service:
  #   type: LoadBalancer
  #   port: 3000
  #   portName: http-web
  #   targetPort: 3000
  serviceMonitor:
    enabled: true
    path: "/metrics"
    scrapeTimeout: 10s
  resources:
    limits:
      cpu: 200m
      memory: 200Mi
    requests:
      cpu: 100m
      memory: 100Mi

  # To make Grafana persistent (Using Statefulset)
  persistence:
    enabled: true
    type: sts
    storageClassName: default
    accessModes:
      - ReadWriteOnce
    size: 5Gi
    finalizers:
      - kubernetes.io/pvc-protection

# PrometheusOperator
prometheusOperator:
   resources:
    limits:
      cpu: 200m
      memory: 200Mi
    requests:
      cpu: 100m
      memory: 100Mi

# Promtetheus Server
prometheus:
  ingress:
    enabled: true
    ingressClassName: external-ingress-nginx-class
    hosts:
      - prometheus.namutest.site
    paths:
      - /    
  # service:
  #   port: 9090
  #   targetPort: 9090
  #   type: LoadBalancer
  prometheusSpec:
    # Detect All Service Monitor & Pod Monitor
    podMonitorSelectorNilUsesHelmValues: false
    serviceMonitorSelectorNilUsesHelmValues: false
    
    # 메트릭 스크랩 scrapeTimeout > scrapeInterval
    scrapeInterval: "15s"
    evaluationInterval: "15s"
    scrapeTimeout: "10s"

    retention:  7d 
    retentionSize: "5GiB"
    
    replicas: 1
    resources:
      limits:
        cpu: 1000m
        memory: 2Gi
      requests:
        cpu: 500m
        memory: 1Gi
    
    storageSpec: 
      volumeClaimTemplate:
        spec:
          storageClassName: azuredisk-ssd-lrs # 미리 단들어둔 스토리지클래스
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 5Gi
          volumeName: restore-prometheus-pv # 프로메테우스의 PV 복구시 PV 먼저 만들고 입력

# Node Exporter
nodeExporter:
  resources:
    limits:
      cpu: 100m
      memory: 256Mi
    requests:
      cpu: 50m
      memory: 128Mi

# Kube State Metrics
kube-state-metrics:
  resources:
    limits:
      cpu: 100m
      memory: 256Mi
    requests:
      cpu: 50m
      memory: 128Mi
